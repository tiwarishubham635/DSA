# DSA for Interns

## Questions 
1. https://practice.geeksforgeeks.org/problems/subarray-with-given-sum-1587115621/1/?track=md-arrays&batchId=144#
2. https://practice.geeksforgeeks.org/problems/sort-an-array-of-0s-1s-and-2s4231/1/?track=md-arrays&batchId=144
3. https://practice.geeksforgeeks.org/problems/-rearrange-array-alternately-1587115620/1/?track=md-arrays&batchId=144#
4. https://practice.geeksforgeeks.org/problems/rotate-array-by-n-elements-1587115621/1/?track=md-arrays&batchId=144
5. https://practice.geeksforgeeks.org/problems/product-array-puzzle4525/1/?track=md-arrays&batchId=144#
6. https://www.interviewbit.com/problems/maximum-absolute-difference/
7. Cycle detection
8. Given an unsorted array of n integers which can contain integers from 1 to n. Some elements can be repeated multiple times and some other elements can be absent from the array. Count the frequency of all elements that are present and print the missing elements.
9. https://practice.geeksforgeeks.org/problems/jump-game/1/?track=md-arrays&batchId=144#
10.https://practice.geeksforgeeks.org/problems/maximize-number-of-1s0905/1/?track=md-arrays&batchId=144#
11.https://practice.geeksforgeeks.org/problems/maximum-index-1587115620/1/?track=md-arrays&batchId=144
12.https://practice.geeksforgeeks.org/problems/k-th-element-of-two-sorted-array1317/1/?track=md-arrays&batchId=144#
13. https://www.interviewbit.com/problems/city-tour/
14.https://practice.geeksforgeeks.org/problems/trapping-rain-water-1587115621/1/?track=md-arrays&batchId=144#
15.https://practice.geeksforgeeks.org/problems/three-sum-closest/1/?track=md-arrays&batchId=144#
16.https://practice.geeksforgeeks.org/problems/max-circular-subarray-sum-1587115620/1/?track=md-arrays&batchId=144#
17. https://practice.geeksforgeeks.org/problems/merge-two-sorted-arrays5135/1/?track=md-arrays&batchId=144
18. Detect if a linked list has a loop and find the starting point of the loop.
19. https://www.interviewbit.com/problems/add-one-to-number/
20. https://www.interviewbit.com/problems/partitions/
21. https://www.interviewbit.com/problems/largest-number/
22. https://www.interviewbit.com/problems/rotate-matrix/
23. https://practice.geeksforgeeks.org/problems/ffd66b6a0bf7cefb9987fa455974b6ea5695709e/1/?track=md-searching&batchId=144#
24. https://practice.geeksforgeeks.org/problems/find-first-and-last-occurrence-of-x0849/1/?track=md-searching&batchId=144#
25. https://practice.geeksforgeeks.org/problems/search-in-a-rotated-array0959/1/?track=md-searching&batchId=144#
26. Given two arrays, one element is there in one array and missing in another. Find it using O(n+m) time and O(1) space.
27.https://practice.geeksforgeeks.org/problems/the-painters-partition-problem1535/1/?track=md-searching&batchId=144#
28.https://practice.geeksforgeeks.org/problems/median-of-2-sorted-arrays-of-different-sizes/1/?track=md-searching&batchId=144
29.https://practice.geeksforgeeks.org/problems/allocate-minimum-number-of-pages0937/1/?track=md-searching&batchId=144#
30.https://practice.geeksforgeeks.org/problems/count-possible-triangles-1587115620/1/?track=md-sorting&batchId=144#
31.https://practice.geeksforgeeks.org/problems/triplets-with-sum-with-given-range/1/?track=md-sorting&batchId=144#
32. https://practice.geeksforgeeks.org/problems/inversion-of-array-1587115620/1/?track=md-sorting&batchId=144
33. https://practice.geeksforgeeks.org/problems/relative-sorting4323/1/?track=md-sorting&batchId=144#
34. https://practice.geeksforgeeks.org/problems/number-of-pairs-1587115620/1/?track=md-sorting&batchId=144
35.https://practice.geeksforgeeks.org/problems/minimum-platforms-1587115620/1/?track=md-sorting&batchId=144#
36.https://practice.geeksforgeeks.org/problems/delete-without-head-pointer/1/?track=md-linkedlist&batchId=144
37. Midpoint of LL - fast reaches end, slow reaches mid
38.https://practice.geeksforgeeks.org/problems/check-if-linked-list-is-pallindrome/1/?track=md-linkedlist&batchId=144#
39.
	https://practice.geeksforgeeks.org/problems/detect-loop-in-linked-list/1/?track=md-linkedlist&batchId=144#
40. 
	https://practice.geeksforgeeks.org/problems/partition-a-linked-list-around-a-given-value/1/?track=md-linkedlist&batchId=144#
41. Copy LL with random pointers.
42. https://practice.geeksforgeeks.org/problems/symmetric-tree/1/?track=md-tree&batchId=144#
43. https://practice.geeksforgeeks.org/problems/level-order-traversal-in-spiral-form/1/?track=md-tree&batchId=144#
44.https://practice.geeksforgeeks.org/problems/check-for-balanced-tree/1/?track=md-tree&batchId=144#
45. https://practice.geeksforgeeks.org/problems/inorder-traversal-iterative/1/?track=md-tree&batchId=144
46. https://practice.geeksforgeeks.org/problems/diameter-of-binary-tree/1/?track=md-tree&batchId=144#

47.	
	https://practice.geeksforgeeks.org/problems/minimum-depth-of-a-binary-tree/1/?track=md-tree&batchId=144#

48.
	https://practice.geeksforgeeks.org/problems/check-if-subtree/1/?track=md-tree&batchId=144

49.
	https://practice.geeksforgeeks.org/problems/top-view-of-binary-tree/1#

50.
	https://practice.geeksforgeeks.org/problems/left-view-of-binary-tree/1#

51.
	https://practice.geeksforgeeks.org/problems/print-a-binary-tree-in-vertical-order/1/?track=md-tree&batchId=144#

52.
	https://practice.geeksforgeeks.org/problems/boundary-traversal-of-binary-tree/1/?track=md-tree&batchId=144#

53.
	https://practice.geeksforgeeks.org/problems/binary-tree-to-dll/1/?track=md-tree&batchId=144

54.
	https://practice.geeksforgeeks.org/problems/maximum-path-sum/1/?track=md-tree&batchId=144

55.
	https://practice.geeksforgeeks.org/problems/burning-tree/1/?track=md-tree&batchId=144#

56.
	https://practice.geeksforgeeks.org/problems/inorder-successor-in-bst/1/?track=md-BST&batchId=144#

57.
	https://practice.geeksforgeeks.org/problems/check-for-bst/1/?track=md-BST&batchId=144#

58.
	https://practice.geeksforgeeks.org/problems/array-to-bst4443/1/?track=md-BST&batchId=144#

59.
	https://practice.geeksforgeeks.org/problems/remove-bst-keys-outside-given-range/1/?track=md-BST&batchId=144

60.
	https://practice.geeksforgeeks.org/problems/find-a-pair-with-given-target-in-bst/1/?track=md-BST&batchId=144#

61.
	https://practice.geeksforgeeks.org/problems/preorder-traversal-and-bst4006/1/?track=md-BST&batchId=144#

62.
	https://practice.geeksforgeeks.org/problems/find-first-set-bit-1587115620/1/?track=md-bm&batchId=144#

63.
	https://practice.geeksforgeeks.org/problems/power-of-2-1587115620/1/?track=md-bm&batchId=144

64.
	https://practice.geeksforgeeks.org/problems/swap-all-odd-and-even-bits-1587115621/1/?track=md-bm&batchId=144

65.
	https://practice.geeksforgeeks.org/problems/rotate-bits4524/1/?track=md-bm&batchId=144

66.
	https://practice.geeksforgeeks.org/problems/reverse-bits3556/1/?track=md-bm&batchId=144#

67.
	https://practice.geeksforgeeks.org/problems/sum-of-two-numbers-without-using-arithmetic-operators/1/?track=md-bm&batchId=144

68.
	https://practice.geeksforgeeks.org/problems/maximum-and-value2637/1/?track=md-bm&batchId=144

69.
	https://practice.geeksforgeeks.org/problems/maximum-subset-xor/1/?track=md-bm&batchId=144

70.
	https://practice.geeksforgeeks.org/problems/find-sum-of-different-corresponding-bits-for-all-pairs4652/1/?track=md-bm&batchId=144

71.
	https://practice.geeksforgeeks.org/problems/zero-sum-subarrays1825/1/?track=md-hashing&batchId=144

72.
	https://practice.geeksforgeeks.org/problems/combination-sum-part-21208/1/?track=md-recursion&batchId=144

73.
	https://practice.geeksforgeeks.org/problems/egg-dropping-puzzle-1587115620/1/?track=md-dp&batchId=144

74.
	https://practice.geeksforgeeks.org/problems/coin-change2448/1/?track=md-dp&batchId=144

75.
	https://leetcode.com/problems/maximum-product-of-word-lengths/

76.
	https://practice.geeksforgeeks.org/problems/longest-increasing-subsequence-1587115620/1/?track=md-dp&batchId=144

77.
	https://practice.geeksforgeeks.org/problems/box-stacking/1/?track=md-dp&batchId=144

78.
	https://practice.geeksforgeeks.org/problems/longest-palindrome-in-a-string1956/1/?track=md-dp&batchId=144#

79.
	https://practice.geeksforgeeks.org/problems/longest-common-substring1452/1/?track=md-dp&batchId=144#

80.
	https://leetcode.com/problems/majority-element/

81.
	https://leetcode.com/problems/move-zeroes/

82.
	https://leetcode.com/problems/happy-number/

83.
	https://practice.geeksforgeeks.org/problems/wildcard-pattern-matching/1/?track=md-dp&batchId=144#
































































Answers
1. 
/*vector<int> subarraySum(int arr[], int n, int s) // Handles only positive numbers
    {
        int l = 0, r = 0, sum = arr[l];
        while (r < n)
        {
            if (sum == s)
            {
                vector<int> ans;
                ans.push_back(l + 1);
                ans.push_back(r + 1);
                return ans;
            }
            if (sum < s)
            {
                r++;
                sum += arr[r];
            }
            else
            {
                while (sum > s)
                {
                    sum -= arr[l];
                    l++;
                }
            }
        }
        //cout<<-1<<endl;
        vector<int> ans;
        ans.push_back(-1);
        return ans;
    }*/
    
    vector<int> subarraySum(int arr[], int n, int sum) //handles negatives too
    { 
    	unordered_map<int, int> map;
    	int curr_sum = 0;
    	vector<int>ans;
    
    	for (int i = 0; i < n; i++) 
    	{ 
    		curr_sum = curr_sum + arr[i];
    		if (curr_sum == sum) 
    		{ 
    			ans.push_back(1);
    			ans.push_back(i+1);
    			return ans; 
    		} 
    		
    		if (map.find(curr_sum - sum) != map.end()) 
    		{ 
    			ans.push_back(map[curr_sum - sum] + 1+1); 
    			ans.push_back(i+1); 
    			return ans; 
    		} 
    		map[curr_sum] = i; 
        }
        ans.push_back(-1);
        return ans;
    }

2. 
void sort012(int a[], int n)
    {
        int low = 0;
        int high = n - 1;
        int mid = 0;
     
        while (mid <= high) 
        {
            if(a[mid]==0)
            {
                swap(a[low++], a[mid++]);
            }
                    
            else if(a[mid]==1)
            {
                mid++;
            }
            
            else
            {
                swap(a[mid], a[high--]);
            }
        }
    }
3. 
void rearrange(long long *arr, int n) 
    {
        /* To store two values at a single index, maintain max_ele = max(original array elements)+1;
         dividend = (quotient)*divisor + remainder
         arr[i] = (new value)*divisor + old value
         max_index = n-1, min_index = 0;
         for storing max elements at even index:
            arr[i] = (arr[max_index]%max_ele)*max_ele +    arr[i];
                            (new value)      (divisor)   (old value)
            max_index--
                            
         for storing min elements at odd index:
            arr[i] = (arr[min_index]%max_ele)*max_ele +    arr[i];
                            (new value)      (divisor)   (old value)
            min_index++
            
        finally for all i:
            arr[i] = arr[i]/max_ele;
        */ 
        int max_index = n-1, min_index = 0;
        long long max_ele = arr[n-1]+1;
        for(int i=0;i<n;i++)
        {
            if(i%2==0)
            {
                arr[i] += (arr[max_index]%max_ele)*max_ele;
                max_index--;
            }
            else
            {
                arr[i] += (arr[min_index]%max_ele)*max_ele;
                min_index++;
            }
        }
        for(int i=0;i<n;i++)
        {
            arr[i] = arr[i]/max_ele;
        }
    }

4. 
int gcd(int a, int b)
    {
        if(a<b)
            return gcd(b, a);
        if(b==0)
            return a;
        return gcd(b, a%b);
    }
    //Function to rotate an array by d elements in counter-clockwise direction. 
    void rotateArr(int arr[], int d, int n)
    {
        int g = gcd(n, d);
        for(int i=0;i<g;i++)
        {
            int tmp = arr[i];
            for(int j=i;;j = (j+d)%n)
            {
                if((j+d)%n==i)
                {
                    arr[j] = tmp;
                    break;
                }
                arr[j] = arr[(j+d)%n];
            }
        } 
}
5. 
void productPuzzle(int a[], int n)
{
    // to hold sum of all values
    long double sum = 0;
    for (int i = 0; i < n; i++)
        sum += (long double)log10(a[i]);

    // output product for each index
    // antilog to find original product value
    for (int i = 0; i < n; i++)
        cout << (int)(EPS + pow((long double)10.00,
                                sum - log10(a[i])))
             << " ";
}

6. 
int Solution::maxArr(vector<int> &a) 
{
    int m1 = a[0], m2 = a[0];
    for(int i=1;i<a.size();i++)
    {
        if(m1<a[i]-i)
            m1 = a[i]-i;
        if(m2>a[i]-i)
            m2 = a[i]-i;
    }
    
    int m3 = a[0], m4 = a[0];
    for(int i=1;i<a.size();i++)
    {
        if(m3<a[i]+i)
            m3 = a[i]+i;
        if(m4>a[i]+i)
            m4 = a[i]+i;
    }
    
    return max(m1-m2, m3-m4);
}
7. 
#include <iostream>
using namespace std;

int findParent(int v, int* parent)
{
    while(parent[v]!=v)
    {
        v = parent[v];
    }
    return parent[v];
}

bool isCycle(int** graph, int v, int e)
{
    int* parent = new int[v];
    for(int i=0;i<v;i++)
        parent[i] = i;
    for(int i=0;i<e;i++)
    {
        int x = findParent(graph[i][0], parent);
        int y = findParent(graph[i][1], parent);
        
        if(x==y)
            return true;
        parent[x] = y;
    }
    return false;
}

int main() 
{
	int v, e;
	cin>>v>>e;
	int** graph = new int*[e];
	for(int i=0;i<e;i++)
	    graph[i] = new int[2];
	for(int i=0;i<e;i++)
	    cin>>graph[i][0]>>graph[i][1];
	cout<<isCycle(graph, v, e);
	return 0;
}
8. 
Approach -1 :
void findCounts(int *arr, int n)
{
    // Traverse all array elements
    int i = 0;
    while (i<n)
    {
        // If this element is already processed,
        // then nothing to do
        if (arr[i] <= 0)
        {
            i++;
            continue;
        }

        // Find index corresponding to this element
        // For example, index for 5 is 4
        int elementIndex = arr[i]-1;

        // If the elementIndex has an element that is not
        // processed yet, then first store that element
        // to arr[i] so that we don't lose anything.
        if (arr[elementIndex] > 0)
        {
            arr[i] = arr[elementIndex];

            // After storing arr[elementIndex], change it
            // to store initial count of 'arr[i]'
            arr[elementIndex] = -1;
        }
        else
        {
            // If this is NOT first occurrence of arr[i],
            // then decrement its count.
            arr[elementIndex]--;

            // And initialize arr[i] as 0 means the element
            // 'i+1' is not seen so far
            arr[i] = 0;
            i++;
        }
    }

    printf("\nBelow are counts of all elements\n");
    for (int i=0; i<n; i++)
        printf("%d -> %d\n", i+1, abs(arr[i]));
}
	Approach 2:
void printfrequency(int arr[],int n)
{
    // Subtract 1 from every element so that the elements
    // become in range from 0 to n-1
    for (int j =0; j<n; j++)
        arr[j] = arr[j]-1;

    // Use every element arr[i] as index and add 'n' to
    // element present at arr[i]%n to keep track of count of
    // occurrences of arr[i]
    for (int i=0; i<n; i++)
        arr[arr[i]%n] = arr[arr[i]%n] + n;

    // To print counts, simply print the number of times n
    // was added at index corresponding to every element
    for (int i =0; i<n; i++)
        cout << i + 1 << " ->  " << arr[i]/n << endl;
}
9. O(n2) solution
int canReach(int a[], int n) 
    {
        int* dp = new int[n];
        dp[0] = 1; // dp[i] denotes if we can reach index i from index 0
                    // for jumps to reach, dp[0] = 0
        for(int i=1;i<n;i++)
        {
            dp[i] = 0; // for jumps dp[i] = INT_MAX
            for(int j =0; j<i;j++)
            {
                if(i<=j+a[j]&&dp[j]!=0)
                {
                    dp[i] = 1; // for jumps dp[i] = max(dp[i], dp[j]+1)
                    break;
                }
            }
        }
        return dp[n-1];
    }
	O(N) Approach:

int canReach(int a[], int n) 
    {
       if(n<=1)
        return 1; // 0 jumps required
        
        if(a[0]==0)
            return 0; // not possible to reach
            
        int maxReach = a[0], steps = a[0], jumps = 1; // steps = no. of steps which are 
                                                      // left to be taken
        for(int i=1; i<n;i++)
        {
            if(i==n-1)
                return 1; //return jumps;
            
            maxReach = max(maxReach, i+a[i]);
            steps--;
            if(steps==0)
            {
                jumps++;
                
                if(i>=maxReach)
                    return 0; // return -1; // not possible to move forawrd from index i
                
                steps = maxReach - i;
            }
        }
        return 1;
    }
10. 
int findZeroes(int arr[], int n, int m) 
    {
        int l =0, r=0, zeroes=0, best = 0;
        while(r<n)
        {
            if(arr[r]==0)
                zeroes;
            if(zeroes<=m)
                r++;
            else
            {
                best = ((r-l)>best)?(r-l):best;
                while(zeroes>m)
                {
                    zeroes = arr[l]==0?zeroes-1:zeroes;
                    l++;
                }
                r++;
            }
        }
        return ((r-l)>best)?(r-l):best;
    }  

11.
int maxIndexDiff(int arr[], int n) 
    {
        int* leftmin = new int[n]; // smallest element from index 0 to i included
        int* rightmax = new int[n]; // largest element from index n-1 to i included
        leftmin[0] = arr[0];
        rightmax[n-1] = arr[n-1];
        for(int i=1;i<n;i++)
        {
            leftmin[i] = leftmin[i-1]<arr[i]?leftmin[i-1]:arr[i];
            rightmax[n-i-1] = rightmax[n-i]>arr[n-i-1]?rightmax[n-i]:arr[n-i-1];
        }
        
        int diff = INT_MIN;
        for(int i=0, j=0; i<n&&j<n; )
        {
            if(leftmin[i]<=rightmax[j])
            {
                diff = diff>(j-i)?diff:(j-i);
                j++;
            }
            else
                i++;
        }
        return diff;
    }

12. O(n+m) Approach
	int kthElement(int arr1[], int arr2[], int n, int m, int ct)
    {
        int i, j, k;
        for(i=0, j=0, k=0; i<n&&j<m;)
        {
            if(arr1[i]<arr2[j])
            {
                k++;
                if(k==ct)
                    return arr1[i];
                i++;
            }
            else
            {
                k++;
                if(k==ct)
                    return arr2[j];
                j++;
            }
        }
        if(i<n)
        {
            while(i<n)
            {
                k++;
                if(k==ct)
                    return arr1[i];
                i++;
            }
        }
        
        else if(j<m)
        {
            while(j<m)
            {
                k++;
                if(k==ct)
                    return arr2[j];
                j++;
            }
        }
        return arr2[m-1];
    }

O(logn + logm) Approach

int kthElement(int arr1[], int arr2[], int n, int m, int k)
    {
        if(n==0)
            return arr2[k-1];
        if(m==0)
            return arr1[k-1];
        
        int mid1 = n/2, mid2 = m/2;
        if(mid1 + mid2 < k-1)
        {
            if(arr1[mid1]<arr2[mid2])
                return kthElement(arr1+mid1+1, arr2, n-mid1-1, m, k-mid1-1);
            else
                return kthElement(arr1, arr2+mid2+1, n, m-mid2-1, k-mid2-1);
        }
        else
        {
            if(arr1[mid1]<arr2[mid2])
                return kthElement(arr1, arr2, n, mid2, k);
            else
                return kthElement(arr1, arr2, mid1, m, k);
        }
        return 0;
}

O(k) approach

int kthElement(int arr1[], int arr2[], int n, int m, int k)
    {
        if(n>m)
            return kthElement(arr2, arr1, m, n, k);
        if(n==0)
            return arr2[k-1];
        
        if(k==1)
            return min(arr1[0], arr2[0]);
            
        int i = min(n, k/2), j = min(m, k/2);
        if(arr1[i-1]>arr2[j-1])
            return kthElement(arr1, arr2+j, n, m-j, k-j);
        else
            return kthElement(arr1+i, arr2, n-i, m, k-i);
    }

13. O(nlogn) Approach
long long int fact(long long int n)
{
    long long int f = 1;
    for(long long int i=2;i<=n;i++)
        f = (f*i)%1000000007;
    return f;
}

long long int power(long long int a, long long int b)
{
    if(b==0)
        return 1;
        
    if(b==1)
        return a;
    long long int tmp = (power(a, b/2))%1000000007;
    if(b%2==0)
        return (tmp*tmp)%1000000007;
    return (((a*tmp)%1000000007)*tmp)%1000000007;
}

int Solution::solve(int m, vector<int> &a) 
{
    int n = a.size(); int mod = 1000000007;
    sort(a.begin(), a.end());
    vector<int>b;
    b.push_back(a[0]-1);
    for(int i=1;i<n;i++)
        b.push_back(a[i]-a[i-1]-1);
    b.push_back(m-a[n-1]);
    long long ans = fact(m-n);
    for(int i=0;i<b.size();i++)
        ans = (ans*(power(fact(b[i]), mod-2))%mod)%mod; 
    for(int i=1;i<b.size()-1;i++)
    {
        if(b[i]>1)
            ans = (ans*(power(2, b[i]-1))%mod)%mod;       
    }
    return ans%mod;
}

14. O(n) Time and O(n) Space
int trappingWater(int arr[], int n)
    {
        int* left = new int[n];
        int* right = new int[n];
        
        left[0] = arr[0];
        right[n-1] = arr[n-1];
        for(int i=1;i<n;i++)
        {
            left[i] = max(left[i-1], arr[i]);
            right[n-i-1] = max(right[n-i], arr[n-i-1]);
        }
        
        int area = 0;
        for(int i=0;i<n;i++)
            area += (min(left[i], right[i])-arr[i]);
        return area;
    }
O(n) Time and O(1) Space
int trappingWater(int arr[], int n)
    {
        int l=0, r=n-1;
        int left_max = 0, right_max=0;
        int area =0;
        while(l<=r)
        {
            if(left_max<=right_max)
            {
                area += max(0, left_max-arr[l]);
                left_max = max(left_max, arr[l]);
                l++;
            }
            else
            {
                area += max(0, right_max-arr[r]);
                right_max = max(right_max, arr[r]);
                r--;
            }
        }
        return area;
    }

15. O(n2) approach

int threeSumClosest(vector<int>& arr, int target) 
    {
        sort(arr.begin(), arr.end());
        int closest = INT_MAX;
        int n = arr.size();
        for(int i=0;i<n-2&&closest!=target;i++)
        {
            int ptr1 = i+1, ptr2 = n-1;
            while(ptr1<ptr2&&closest!=target)
            {
                int sum = arr[i]+arr[ptr1]+arr[ptr2];
                if(abs(1ll*target-sum)<abs(1ll*target-closest))
                    closest = sum;
                if(sum<target)
                    ptr1++;
                else
                    ptr2--;
            }
        }
        return closest;
    }

16. Approach 1

int kadane(int a[], int n)
    {
        int curr_max = a[0], best = a[0];
        for(int i=1;i<n;i++)
        {
            curr_max = max(a[i], curr_max+a[i]);
            best = max(curr_max, best);
        }
        return best;
    }
    int circularSubarraySum(int arr[], int n)
    {
        int ans1 = kadane(arr, n);
        if(ans1 < 0)
            return ans1;
        
        int sum =0;
        for(int i=0;i<n;i++)
        {
            sum += arr[i];
            arr[i] *= -1;
        }
        
        int ans2 = sum + kadane(arr, n);
        return max(ans1, ans2);
    }

Approach 2

int circularSubarraySum(int arr[], int n)
    {
        if(n==1)
            return arr[0];
        int curr_max=arr[0], max_so_far = arr[0], curr_min=arr[0], min_so_far = arr[0], sum = arr[0];
        for(int i=1;i<n;i++)
        {
            sum += arr[i];
            curr_max = max(arr[i], curr_max+arr[i]);
            max_so_far = max(curr_max, max_so_far);
            
            curr_min = min(arr[i], curr_min+arr[i]);
            min_so_far = min(curr_min, min_so_far);
        }
        if(min_so_far==sum)
            return max_so_far;
        return max(max_so_far, sum-min_so_far);
    }


17. O(nlogn + mlogm) Approach:

void merge(int arr1[], int arr2[], int n, int m) 
	{
	    int ix=0, iy=0, k=n-1;
	    while(ix<=k&&iy<m)
	    {
	        if(arr1[ix]<=arr2[iy])
    	    {
    	        ix++;
    	    }
    	    else
    	    {
    	        swap(arr1[k], arr2[iy]);
    	        iy++;
    	        k--;
    	    }
	    }
	    sort(arr1, arr1+n);
	    sort(arr2, arr2+m);
	}

	Skipping numbers approach - O(n+m) Approach:


int nextGap(int gap)
    {
        if (gap <= 1)
            return 0;
        return (gap / 2) + (gap % 2);
    }
    
    void merge(int *arr1, int *arr2, int n, int m)
    {
        int i, j, gap = n + m;
        for (gap = nextGap(gap);
             gap > 0; gap = nextGap(gap))
        {
            // comparing elements in the first array.
            for (i = 0; i + gap < n; i++)
                if (arr1[i] > arr1[i + gap])
                    swap(arr1[i], arr1[i + gap]);
    
            // comparing elements in both arrays.
            for (j = gap > n ? gap - n : 0;
                 i < n && j < m;
                 i++, j++)
                if (arr1[i] > arr2[j])
                    swap(arr1[i], arr2[j]);
    
            if (j < m)
            {
                // comparing elements in the second array.
                for (j = 0; j + gap < m; j++)
                    if (arr2[j] > arr2[j + gap])
                        swap(arr2[j], arr2[j + gap]);
            }
        }
    }

O(n+m) Approach - Two values at a place

	void merge(int arr1[], int arr2[], int n, int m) 
	{
	    int max_ele = arr1[0];
	    for(int i=1;i<n;i++)
	        if(max_ele < arr1[i])
	            max_ele = arr1[i];
	            
	   for(int i=0;i<m;i++)
	        if(max_ele < arr2[i])
	            max_ele = arr2[i];
	            
	   max_ele++;//to have unique remainders 
	   int i,j,k;
	   for(i=0, j=0,k=0;i<n&&j<m;)
	   {
	       int e1 = arr1[i]%max_ele; // old value of arr1[i]
	       int e2 = arr2[j]%max_ele; // old value of arr2[j]
	       if(e1<=e2)
	       {
	           if(k<n)
	            arr1[k] += e1*max_ele;
	           else
	            arr2[k-n] += e1*max_ele;
	           k++; i++;
	       }
	       else
	       {
	           if(k<n)
	            arr1[k] += e2*max_ele;
	           else
	            arr2[k-n] += e2*max_ele;
	           k++; j++;
	       }
	   }
	   
	   while(i<n)
	   {
	       if(k<n)
	        arr1[k] += (arr1[i]%max_ele)*max_ele;
	       else
	        arr2[k-n] += (arr1[i]%max_ele)*max_ele;
	       k++; i++;
	   }
	   
	   while(j<m)
	   {
	       if(k<n)
	        arr1[k] += (arr2[j]%max_ele)*max_ele;
	       else
	        arr2[k-n] += (arr2[j]%max_ele)*max_ele;
	       k++; j++;
	   }
	   
	   for(int i=0;i<n;i++)
	    arr1[i] = arr1[i]/max_ele;
	    
	   for(int j=0;j<m;j++)
	    arr2[j] = arr2[j]/max_ele;
	}

18. 
Detect loop in LL:
Take a fast pointer which moves by two at a time and a slow pointer which moves by one at a time. When slow == fast => loop detected. If no loop, speed of fast = 2* speed of slow. So they can't be equal.
The point where slow = fast is the meeting point. To find the starting point of the loop. Take a pointer at start (P1) of linked list and another at the meeting point (p2). 
For slow, it travels N nodes. If distance of Start of loop from start of linked list is D and the distance between start of loop and meeting point is k, then :
For slow:
N = D+K+Ci
where C is the no. of nodes in the loop and i is the no. of rotations of loop completed by slow
Similarly for fast:
2N = D+K+Cj
where Fast has completed j rotations of the loop. 
From these equations, we get:
D = (j-2i)C - K
So, the distance between the start of the linked list and Start of loop is the same as the distance from the meeting point in the loop falling short by k.
So, move P1 and P2 one by one and the point where they meet is the start of the loop.

19.

vector<int> Solution::plusOne(vector<int> &A) 
{
    int n=A.size(),carry=0;
    vector<int>res;
    res.push_back((1+A[n-1])%10);
    carry=(1+A[n-1])/10;
    for(int i=n-2;i>=0;i--){
        res.push_back((carry+A[i])%10);
        carry=(carry+A[i])/10;
    }
    if(carry)
     res.push_back(carry);
    int x=res.size();
    for(int i=0;i<x/2;i++)
     swap(res[i],res[x-i-1]);
    while(res[0]==0){
       res.erase(res.begin());
    }
    return res;
}

20. 
	int Solution::solve(int n, vector<int> &a) 
{
    int i,j, sum=0;
    for(i=0;i<n;i++)
        sum += a[i];
    if(sum%3!=0)
        return 0;
    int r1 = sum/3;
    int ans=0;
    /*int* prefix = new int[n];
    int* suffix = new int[n];
    prefix[0]=a[0], suffix[n-1]=a[n-1];
    for(i=1;i<n;i++)
    {
        prefix[i] = prefix[i-1] + a[i];
        suffix[n-i-1] = suffix[n-i] + a[n-i-1];
    }
    for(i=0;i<n-2;i++)
    {
        if(prefix[i]==r1)
        {
            for(j=i+2;j<n;j++)
            {
                if(suffix[j]==r1)
                    ans++;
            }
        }
    }*/
    int* suffix = new int[n];
    int sumr = 0;
    for(i=n-1;i>=0;i--)
    {
        sumr += a[i];
        if(sumr==r1)
            suffix[i] = 1;
        else
            suffix[i] = 0;
    }
    for(i=n-2;i>=0;i--)
        suffix[i] += suffix[i+1]; 
    sumr=0;
    for(i=0;i<n-2;i++)
    {
        sumr += a[i];
        if(sumr==r1)
            ans += suffix[i+2];
    }
    return ans;
}

21.
int myCompare(string X, string Y)
{
    // first append Y at the end of X
    string XY = X.append(Y);
 
    // then append X at the end of Y
    string YX = Y.append(X);
 
    // Now see which of the two formed numbers is greater
    return XY.compare(YX) > 0 ? 1: 0;
}
string Solution::largestNumber(const vector<int> &A) 
{
    vector<string> b;
    for(int i=0;i<A.size();i++){
        b.push_back(to_string(A[i]));
    }
    sort(b.begin(),b.end(),myCompare);
    string ans="";
    for(int i=0;i<b.size();i++){
     ans+=b[i];
    }
    int i=0;
    while(ans[i]=='0'){
        i++;
    }
    if(i==ans.length())
     ans="0";
    return ans;
}

21. 
Approach-1
void Solution::rotate(vector<vector<int> > &a) 
{
    int n = a.size();
    for(int i=0;i<n/2;i++)
    {
        for(int j=i;j<n-i-1;j++)
        {
            int tmp = a[i][j];
            a[i][j] = a[n-1-j][i];
            a[n-1-j][i] = a[n-1-i][n-1-j];
            a[n-1-i][n-1-j] = a[j][n-1-i];
            a[j][n-1-i] = tmp;
        }
    }
}


Approach-2:
void Solution::rotate(vector<vector<int> > &arr) 
{
    int N = arr.size();
    for(int i = 0; i < N; i++)
    {
        for(int j = 0; j < i; j++)
        {
            int temp = arr[i][j];
            arr[i][j] = arr[j][i];
            arr[j][i] = temp;
        }
    }
    
    for(int i = 0; i < N; i++)
    {
        for(int j = 0; j < N / 2; j++)
        {
            int temp = arr[i][j];
            arr[i][j] = arr[i][N - j - 1];
            arr[i][N - j - 1] = temp;
        }
    }
}

22. 

	void Solution::rotate(vector<vector<int> > &arr) 
{
    int N = arr.size();
    for(int i = 0; i < N; i++)
    {
        for(int j = 0; j < i; j++)
        {
            int temp = arr[i][j];
            arr[i][j] = arr[j][i];
            arr[j][i] = temp;
        }
    }
    
    for(int i = 0; i < N; i++)
    {
        for(int j = 0; j < N / 2; j++)
        {
            int temp = arr[i][j];
            arr[i][j] = arr[i][N - j - 1];
            arr[i][N - j - 1] = temp;
        }
    }
}


23. int find_height(int a[], int n, int k)
    {
        sort(a, a+n);
        int l=0,r=a[n-1];
        while(l<=r)
        {
            int mid = (l+r)/2;
            int sum=0;
            for(int i=0;i<n;i++)
                if(a[i]>mid)
                    sum += a[i]-mid;
            if(sum==k)
                return mid;
            if(sum<k)
                r = mid-1;
            else l = mid+1;
        }
        return -1;
    }

24.

	pair<long,long> indexes(vector<long long> v, long long x)
    {
        pair<long,long>ans;
        ans.first=-1,ans.second=-1;
        long long n = v.size();
        long long l =0, r=n-1;
        while(l<=r)
        {
            long long mid = (l+r)/2;
            if((mid==0||v[mid-1]<x)&&v[mid]==x)
            {
                ans.first = mid;
                break;
            }
            if(v[mid]<x)
                l = mid+1;
            else
                r = mid-1;
        }
        l=0,r=n-1;
        while(l<=r)
        {
            long long mid = (l+r)/2;
            if((mid==n-1||v[mid+1]>x)&&v[mid]==x)
            {
                ans.second = mid;
                break;
            }
            if(v[mid]>x)
                r = mid-1;
            else
                l = mid+1;
        }
        return ans;
    }

25. Approach 1:
	
	int binarysearch(vector<int>a, int l, int r, int k)
{
    while(l<=r)
    {
        int mid = (l+r)/2;
        if(a[mid]==k)
            return mid;
        if(a[mid]<k)
            l = mid+1;
        else
            r = mid-1;
    }
    return -1;
}

int Search(vector<int> a, int k) 
{
    int n =a.size();
    int l=0, r=n-1, pivot=-1;
    while(l<=r)
    {
        int mid = (l+r)/2;
        if(mid==n-1||a[mid]>a[mid+1])
        {
            pivot = mid;
            break;
        }
        if(mid==0||a[mid]<a[mid-1])
        {
            pivot = mid-1;
            break;
        }
        if(a[l]<a[mid])
            l = mid+1;
        else
            r = mid-1;
    }
    
    if(pivot==-1)
    {
        return binarysearch(a, 0, n-1, k);
    }
    else
    {
        if(a[pivot]==k)
            return pivot;
        
        if(a[0]<=k)
            return binarysearch(a,0, pivot-1,k);
        else
            return binarysearch(a, pivot+1, n-1, k);
    }
}

APPROACH - 2

int Search(vector<int> a, int k) 
{
    int n =a.size();
    int l=0, r=n-1;
    while(l<=r)
    {
        int mid = (l+r)/2;
        if(a[mid]==k)
            return mid;
        if(a[l]<=a[mid])
        {
            if(k>=a[l]&&k<=a[mid])
                r = mid-1;
            else
                l = mid+1;
        }
        else
        {
            if(k>=a[mid+1]&&k<=a[r])
                l = mid+1;
            else
                r = mid-1;
        }
    }
    return -1;
}

26. 
	void findMissing(int arr1[], int arr2[], int M, int N)
{
    if (M != N-1 && N != M-1)
    {
        cout << "Invalid Input";
        return;
    }

    // Do XOR of all element
    int res = 0;
    for (int i=0; i<M; i++)
       res = res^arr1[i];
    for (int i=0; i<N; i++)
       res = res^arr2[i];

    cout << "Missing element is " << res;
}

27.
	long long no_of_painters(int a[], int n, long long max_len)
    {
        long long total=0, painters =1;
        for(long long i=0;i<n;i++)
        {
            total += a[i];
            if(total > max_len)
            {
                total = a[i];
                painters++;
            }
        }
        return painters;
    }
    long long minTime(int a[], int n, int k)
    {
        long long sum = a[0], mx = a[0];
        for(long long i=1;i<n;i++)
        {
            sum += a[i];
            if(mx<a[i])
                mx = a[i];
        }
        
        while(mx <= sum)
        {
            long long mid = (mx+sum)/2;
            long long p = no_of_painters(a, n, mid);
            if(p<=k)
                sum = mid-1;
            else
                mx = mid+1;
        }
        return mx;
    }

28.
	// A utility function to find median of two integers
double MO2(int a, int b)
{
    return (a + b) / 2.0;
}

// A utility function to find median of three integers
double MO3(int a, int b, int c)
{
    return a + b + c - max(a, max(b, c)) - min(a, min(b, c));
}

// A utility function to find a median of four integers
double MO4(int a, int b, int c, int d)
{
    int Max = max(a, max(b, max(c, d)));
    int Min = min(a, min(b, min(c, d)));
    return (a + b + c + d - Max - Min) / 2.0;
}

// Utility function to find median of single array
double medianSingle(int arr[], int n)
{
    if (n == 0)
        return -1;
    if (n % 2 == 0)
        return (double)(arr[n / 2] + arr[n / 2 - 1]) / 2;
    return arr[n / 2];
}

double findMedianUtil(int A[], int N, int B[], int M)
{
    if(N>M)
        return findMedianUtil(B, M, A, N);

    if (N == 0)
        return medianSingle(B, M);

    if (N == 1)
    {
        // Case 1: If the larger array also has one element,
        // simply call MO2()
        if (M == 1)
            return MO2(A[0], B[0]);

        // Case 2: If the larger array has odd number of elements,
        // then consider the middle 3 elements of larger array and
        // the only element of smaller array. Take few examples
        // like following
        // A = {9}, B[] = {5, 8, 10, 20, 30} and
        // A[] = {1}, B[] = {5, 8, 10, 20, 30}
        if (M%2!=0)
            return MO4(B[M / 2], A[0], B[M / 2 - 1], B[M / 2 + 1]);
            
        // Case 3: If the larger array has even number of element,
        // then median will be one of the following 3 elements
        // ... The middle two elements of larger array
        // ... The only element of smaller array
        return MO3(B[M / 2], B[M / 2 - 1], A[0]);
    }

    // If the smaller array has two elements
    else if (N == 2)
    {
        // Case 4: If the larger array also has two elements,
        // simply call MO4()
        if (M == 2)
            return MO4(A[0], A[1], B[0], B[1]);

        // Case 5: If the larger array has odd number of elements,
        // then median will be one of the following 3 elements
        // 1. Middle element of larger array
        // 2. Max of first element of smaller array and element
        //    just before the middle in bigger array
        // 3. Min of second element of smaller array and element
        //    just after the middle in bigger array
        if (M%2!=0)
            return MO3(B[M / 2], max(A[0], B[M / 2 - 1]), min(A[1], B[M / 2 + 1]));

        // Case 6: If the larger array has even number of elements,
        // then median will be one of the following 4 elements
        // 1) & 2) The middle two elements of larger array
        // 3) Max of first element of smaller array and element
        //    just before the first middle element in bigger array
        // 4. Min of second element of smaller array and element
        //    just after the second middle in bigger array
        return MO4(B[M / 2], B[M / 2 - 1], max(A[0], B[M / 2 - 2]), min(A[1], B[M / 2 + 1]));
    }

    int idxA = (N - 1) / 2;
    int idxB = (M - 1) / 2;

    /* if A[idxA] <= B[idxB], then median must exist in
        A[idxA....] and B[....idxB] */
    if (A[idxA] <= B[idxB])
        return findMedianUtil(A + idxA, N / 2 + 1, B, M - idxA);

    /* if A[idxA] > B[idxB], then median must exist in
       A[...idxA] and B[idxB....] */
    return findMedianUtil(A, N / 2 + 1, B + idxA, M - idxA);
}

double MedianOfArrays(vector<int> &a, vector<int> &b)
{
    int N = a.size(), M = b.size();
    int* A = new int[N];
    int* B = new int[M];
    for(int i=0;i<N;i++)
        A[i] = a[i];
    for(int i=0;i<M;i++)
        B[i] = b[i];

    return findMedianUtil(A, N, B, M);
}

29.
	bool possible(int a[], int n, int max_len, int m)
    {
        int total=0, students = 1;
        for(int i=0;i<n;i++)
        {
            if(a[i]>max_len)
                return 0;
            total += a[i];
            if(total > max_len)
            {
                total = a[i];
                students++;
                if(students>m)
                    return 0;
            }
        }
        return 1;
    }
    //Function to find minimum number of pages.
    int findPages(int a[], int n, int m) 
    {
        long long sum=a[0];
        for(int i=1;i<n;i++)
        {
            sum += a[i];
        }
        int mx = 0;
        int result = INT_MAX;
        while(mx<=sum)
        {
            int mid = (mx + sum)/2;
            
            if(possible(a, n, mid, m))
                result = min(result, mid), sum = mid-1;
                
            else
                mx = mid+1;
        }
        return result;
    }

30.
	int findNumberOfTriangles(int arr[], int n)
    {
        sort(arr, arr+n);
        int count=0;
        
        // Approach 1
        
        /*for(int i=0;i<n-2;i++)
        {
            int k=i+2;
            for(int j=i+1;j<n;j++)
            {
                while(k<n&&arr[i]+arr[j]>arr[k])
                    k++;
                
                if(k>j)
                    count += (k-1)-j;
            }
        }*/
        
        // Approach 2
        for(int i=n-1;i>1;i--)
        {
            int l = 0, r = i-1;
            while(l<r)
            {
                if(arr[l]+arr[r]>arr[i])
                {
                    count += r-l;
                    r--;
                }
                else
                    l++;
            }
        }
        return count;
    }

31.
	int countTriplets(int a[], int n, int l, int r) 
    {
        sort(a,a+n);
        int count=0;
        for(int i=0;i<n-2;i++)
        {
            int j = i+1, k = n-1;
            while(j<k)
            {
                int sum = a[i]+a[j]+a[k];
                if(sum<=r)
                    count+= (k-j), j++;
                else
                    k--;
            }
        }
        
        for(int i=0;i<n-2;i++)
        {
            int j = i+1, k = n-1;
            while(j<k)
            {
                int sum = a[i]+a[j]+a[k];
                if(sum<l)
                    count-= (k-j), j++;
                else
                    k--;
            }
        }
        
        return count;
    }
32.
long long int mergesort(long long arr[], long long start, long long end, long long tmp[])
    {
        if (start >= end)
            return 0;
    
        long long int mid = (start + end) / 2;
        long long int ans = mergesort(arr, start, mid, tmp);
        ans += mergesort(arr, mid + 1, end, tmp);
    
        long long i, j, k;
        for (i = start, j = mid, k = start; i <= mid && j <= end;)
        {
            if (arr[i] <= arr[j])
            {
                tmp[k++] = arr[i++];
            }
            else
            {
                tmp[k++] = arr[j++];
                ans += (mid+1-i);
            }
        }

        if (i <= mid)
        {
            while (i <= mid)
            {
                tmp[k++] = arr[i++];
            }
        }
    
    
        if (j <= end)
        {
            while (j <= end)
            {
                tmp[k++] = arr[j++];
            }
        }
    
        for (int i = start; i <= end; i++)
            arr[i] = tmp[i];
    
        /*for (int i = start; i <= end; i++)
            cout << arr[i] << " ";
        cout << endl;*/
        return ans;
    }
    
    long long int inversionCount(long long arr[], long long n)
    {
        long long* tmp = new long long[n];
        for (long long i = 0; i < n; i++)
            tmp[i] = arr[i];
        return mergesort(arr, 0, n - 1, tmp);
    }

33.
	
// A C++ program to sort an array according to the order defined
// by another array
#include <stdio.h>
#include <stdlib.h>

// A2 is made global here so that it can be accessed by compareByA2()
// The syntax of qsort() allows only two parameters to compareByA2()
int A2[5];

// size of A2[]
int size = 5;

int search(int key)
{
    int i = 0, idx = 0;
    for (i = 0; i < size; i++)
        if (A2[i] == key)
            return i;
    return -1;
}

// A custom compare method to compare elements of A1[] according
// to the order defined by A2[].
int compareByA2(const void* a, const void* b)
{
    int idx1 = search(*(int*)a);
    int idx2 = search(*(int*)b);
    if (idx1 != -1 && idx2 != -1)
        return idx1 - idx2;
    else if (idx1 != -1)
        return -1;
    else if (idx2 != -1)
        return 1;
    else
        return (*(int*)a - *(int*)b);
}

// This method mainly uses qsort to sort A1[] according to A2[]
void sortA1ByA2(int A1[], int size1)
{
    qsort(A1, size1, sizeof(int), compareByA2);
}

// Driver program to test above function
int main(int argc, char* argv[])
{
    int A1[] = { 2, 1, 2, 5, 7, 1, 9, 3, 6, 8, 8, 7, 5, 6, 9, 7, 5 };

    // A2[] = {2, 1, 8, 3, 4};
    A2[0] = 2;
    A2[1] = 1;
    A2[2] = 8;
    A2[3] = 3;
    A2[4] = 4;
    int size1 = sizeof(A1) / sizeof(A1[0]);

    sortA1ByA2(A1, size1);

    printf("Sorted Array is ");
    int i;
    for (i = 0; i < size1; i++)
        printf("%d ", A1[i]);
    return 0;
}

34.
	long long pair(int x, int b[], int m, long long* y)
    {
        if(x==0)
            return 0;
        if(x==1)
            return y[0];
        long long idx=(b+m)-upper_bound(b,b+m,x);
        idx += (y[0]+y[1]);
        if (x == 2)
		    idx -= (y[3] + y[4]);

    	if (x == 3)
    		idx += y[2];
    
    	return idx;
    }
    
    long long countPairs(int a[], int b[], int n, int m)
    {
       sort(b,b+m);
       long long count=0;
       
       long long* y = new long long[5];
       for(long long i=0;i<m;i++)
        if(b[i]<5)
            y[b[i]]++;
            
       for(long long i=0;i<n;i++)
        count += pair(a[i], b, m, y);
       return count;
    }

35.
	int findPlatform(int arr[], int dep[], int n)
    {
    	/*sort(arr,arr+n);
    	sort(dep,dep+n);
    	int i=1,j=0;
    	int ans=1,plat=1;
    	while(i<n&&j<n)
    	{
    	    if(arr[i]<=dep[j])
    	        plat++, i++;
    	    else plat--, j++;
    	    ans = max(ans, plat);
    	}*/
    	int* platform = new int[2361];
    	int ans=1;
    	for(int i=0;i<n;i++)
    	{
    	    platform[arr[i]]++;
    	    platform[dep[i]+1]--;
    	}
    	for(int i=1;i<2361;i++)
    	{
    	    platform[i] += platform[i-1];
    	    ans = max(ans, platform[i]);
    	}
    	return ans;
    }


36.
	void deleteNode(Node *del)
    {
       if(del->next==NULL)
        {
            del=NULL;
            return;
        }
        del->data = del->next->data;
        del->next = del->next->next;
    }

38.
bool isPalindrome(Node *head)
    {
        /*if(head==NULL)
            return true;
        if(head->next==NULL)
            return true;
        Node* tmp = head;
        Node* prev = NULL;
        while(tmp->next!=NULL)
        {
            prev = tmp;
            tmp= tmp->next;
        }
        if(tmp->data!=head->data)
            return false;
        else
        {
            prev->next = NULL;
            return isPalindrome(head->next);
        }*/
        if(head->next==NULL)
            return true;
        Node* slow = head;
        Node* fast = head;
        
        while(fast!=NULL&&fast->next!=NULL)
        {
            slow = slow->next;
            fast = fast->next->next;
        }
        if(fast==NULL)
        {
            Node* prev = NULL;
            Node* curr = slow;
            Node* future = curr->next;
            while(future!=NULL)
            {
                curr->next = prev;
                prev = curr;
                curr = future;
                future = future->next;
            }
            curr->next = prev;
            Node* newHead = curr;
            
            Node* tmp = head;
            while(tmp!=slow&&curr!=NULL)
            {
                if(tmp->data!=curr->data)
                    return false;
                tmp = tmp->next;
                curr = curr->next;
            }
            return true;
        }
        else
        {
            Node* prev = NULL;
            Node* curr = slow->next;
            Node* future = curr->next;
            while(future!=NULL)
            {
                curr->next = prev;
                prev = curr;
                curr = future;
                future = future->next;
            }
            curr->next = prev;
            Node* newHead = curr;
            
            Node* tmp = head;
            while(tmp!=slow&&curr!=NULL)
            {
                if(tmp->data!=curr->data)
                    return false;
                tmp = tmp->next;
                curr = curr->next;
            }
            return true;
        }
    }

39.
	bool detectLoop(Node* head)
    {
        if(head->next==NULL)
            return false;
        Node* slow = head, *fast = head->next->next;
        while(fast!=NULL&&fast->next!=NULL)
        {
            if(slow==fast)
                return true;
            slow = slow->next;
            fast = fast->next->next;
        }
        return false;
    }

40. 
	struct Node* partition(struct Node* head, int x) 
{
    Node* lessStart=NULL, *lessEnd = NULL;
    Node* equalStart=NULL, *equalEnd = NULL;
    Node* greaterStart=NULL, *greaterEnd = NULL;
    Node* tmp = head;
    while(head!=NULL)
    {
        if(head->data < x)
        {
            if(lessStart==NULL)
                lessStart=lessEnd=head;
            else
                lessEnd->next = head, lessEnd = head;
        }
        else if( head->data == x)
        {
            if(equalStart==NULL)
                equalStart=equalEnd=head;
            else
                equalEnd->next = head, equalEnd = head;
        }
        else
        {
            if(greaterStart==NULL)
                greaterStart=greaterEnd=head;
            else
                greaterEnd->next = head, greaterEnd = head;
        }
        head = head->next;
    }
    
    if(greaterEnd!=NULL)
        greaterEnd->next = NULL;
    if(lessStart==NULL)
    {
        if(equalStart==NULL)
            return greaterStart;
        equalEnd->next = greaterStart;
        return equalStart;
    }
    else
    {
        if(equalStart==NULL)
        {
            if(greaterStart==NULL)
            {
                lessEnd->next = NULL;
                return lessStart;
            }
            else
            {
                lessEnd->next = greaterStart;
                return lessStart;
            }
        }
        else
        {
            lessEnd->next = equalStart;
            if(greaterStart==NULL)
            {
                equalEnd->next = NULL;
                return lessStart;
            }
            else
            {
                equalEnd->next = greaterStart;
                return lessStart;
            }
        }
    }
}

41.
	https://www.geeksforgeeks.org/clone-linked-list-next-random-pointer-o1-space/
42.
	bool isMirror(Node* root1, Node* root2)
{
    if(root1==NULL&&root2==NULL)
        return true;
    if(root1&&root2&&root1->data == root2->data)
        return isMirror(root1->left, root2->right)&&isMirror(root1->right, root2->left);
    return false;
}

bool isSymmetric(struct Node* root)
{
	return isMirror(root, root);
}

43.
	vector<int> findSpiral(Node *root)
{
    vector<int>ans;
    if(root==NULL)
        return ans;
        
    stack<Node*>s1;
    stack<Node*>s2;
    
    s1.push(root);
    while((!s1.empty())||(!s2.empty()))
    {
        while(!s1.empty())
        {
            Node* val = s1.top();
            s1.pop();
            if(val->right!=NULL)
                s2.push(val->right);
            if(val->left!=NULL)
                s2.push(val->left);
            ans.push_back(val->data);
        }
        
        while(!s2.empty())
        {
            Node* val = s2.top();
            s2.pop();
            if(val->left!=NULL)
                s1.push(val->left);
            if(val->right!=NULL)
                s1.push(val->right);
            ans.push_back(val->data);
        }
    }
    
    return ans;
}

44.
	int height(Node* root)
{
    if(root==NULL)
        return 0;
    if(root->left==NULL&&root->right==NULL)
        return 1;
    return 1+max(height(root->left),height(root->right));
}

bool isBalanced(Node *root)
{
    if(root==NULL)
        return true;
    int n1 = height(root->left);
    int n2 = height(root->right);
    if(abs(n1-n2)<=1&&isBalanced(root->left)&&isBalanced(root->right))
        return true;
    else
        return false;
}

45.
	vector<int> inOrder(Node* root)
    {
        vector<int>ans;
        if(root==NULL)
            return ans;
        Node* tmp = root;
        stack<Node*>s;
        while(tmp!=NULL||!s.empty())
        {
            while(tmp!=NULL)
            {
                s.push(tmp);
                tmp = tmp->left;
            }
            
            Node* val = s.top();
            s.pop();
            ans.push_back(val->data);
            tmp = val->right;
        }
    }
vector<int> preOrder(Node* root)
{
    vector<int>ans;
    if(root==NULL)
        return ans;
    stack<Node*>s;
    s.push(root);
    while(!s.empty())
    {
        Node* val = s.top();
        ans.push_back(val->data);
        s.pop();
        if(val->right)
            s.push(val->right);
        if(val->left)
            s.push(val->left);
    }
    return ans;
}
vector<int> postOrder(Node* root) 
{
    vector<int>ans;
    if(root==NULL)
        return ans;
    stack<Node*>s1;
    stack<Node*>s2;
    s1.push(root);
    while(!s1.empty())
    {
        Node* val = s1.top();
        s1.pop();
        s2.push(val);
        if(val->left)
            s1.push(val->left);
        if(val->right)
            s1.push(val->right);
    }
    while(!s2.empty())
    {
        Node* val = s2.top();
        ans.push_back(val->data);
        s2.pop();
    }
    return ans;
}

46.
	int diameter(Node* root)
    {
        if(root==NULL)
            return 0;
        if(root->left==NULL&&root->right==NULL)
            return 1;
        int d1 = diameter(root->left);
        int d2 = diameter(root->right);
        return max(1+height(root->left)+height(root->right),max(d1,d2));
    }

47.
	int minDepth(Node *root) 
    {
        if(root==NULL)
            return 0;
        if(root->left==NULL&&root->right==NULL)
            return 1;
        else if(root->left==NULL)
            return 1+minDepth(root->right);
        else if(root->right==NULL)
            return 1+minDepth(root->left);
        else return 1+min(minDepth(root->left), minDepth(root->right));
    }

48.
	void storeInorder(Node* root, char arr[], int& i)
    {
        if (root == NULL) {
            arr[i++] = '$';
            return;
        }
        storeInorder(root->left, arr, i);
        arr[i++] = root->data;
        storeInorder(root->right, arr, i);
    }
    
    // A utility function to store preorder traversal of tree rooted
    // with root in an array arr[]. Note that i is passed as reference
    void storePreOrder(Node* root, char arr[], int& i)
    {
        if (root == NULL) {
            arr[i++] = '$';
            return;
        }
        arr[i++] = root->data;
        storePreOrder(root->left, arr, i);
        storePreOrder(root->right, arr, i);
    }
    
    bool isSubTree(Node* T, Node* S)
    {
        if (S == NULL)
        return true;
        if (T == NULL)
            return false;
    
        // Store Inorder traversals of T and S in inT[0..m-1]
        // and inS[0..n-1] respectively
        int m = 0, n = 0;
        char inT[MAX], inS[MAX];
        storeInorder(T, inT, m);
        storeInorder(S, inS, n);
        inT[m] = '\0', inS[n] = '\0';
    
        // If inS[] is not a substring of inT[], return false
        if (strstr(inT, inS) == NULL)
            return false;
    
        // Store Preorder traversals of T and S in preT[0..m-1]
        // and preS[0..n-1] respectively
        m = 0, n = 0;
        char preT[MAX], preS[MAX];
        storePreOrder(T, preT, m);
        storePreOrder(S, preS, n);
        preT[m] = '\0', preS[n] = '\0';
    
        // If preS[] is not a substring of preT[], return false
        // Else return true
        return (strstr(preT, preS) != NULL);
    }

49.
	Determine the vertical order traversal and add the first root with new horizontal distance in the top view.
Vertical order is printing nodes according to their horizontal distance from the root. So horizontal distance of root = 0, and for any child:
Horizontal distance of left child = Horizontal distance of parent - 1
Horizontal distance of right child = Horizontal distance of parent + 1
So, maintain a map of horizontal distance and keep pushing the nodes having that value as horizontal distance.

vector<int> topView(Node *root)
    {
        map<int, int> hd;
        hd[root->data] = 0;
        queue<Node *> q;
        q.push(root);
        map<int,int>mp;
        while (!q.empty())
        {
            Node *val = q.front();
            q.pop();
            if(mp.count(hd[val->data])==0)
                mp[hd[val->data]]=val->data;
            if (val->left)
                hd[val->left->data] = hd[val->data] - 1, q.push(val->left);
            if (val->right)
                hd[val->right->data] = hd[val->data] + 1, q.push(val->right);
        }
        vector<int>answer;
        for(auto i = mp.begin(); i!=mp.end();i++)
            answer.push_back(i->second);
        return answer;
    }
Similarly for the bottom view, we need to add the last node with horizontal distance in the bottom view.

vector <int> bottomView(Node *root)
{
    vector<int>answer;
    if(root==NULL)
        return answer;
    int hd = 0;
    queue<pair<Node *, int>> q;
    q.push(make_pair(root, hd));
    map<int,int>mp;
    while (!q.empty())
    {
        pair<Node*, int> p = q.front();
        Node *val = p.first;
        hd = p.second;
        q.pop();
        mp[hd] = val->data;
        if (val->left)
            q.push(make_pair(val->left, hd-1));
        if (val->right)
            q.push(make_pair(val->right, hd+1));
    }
    for(auto i = mp.begin(); i!=mp.end();i++)
        answer.push_back(i->second);
    return answer;
}

50.
	void levelorder(Node* root, vector<vector<int>> &ans)
{
    if (root == NULL)
        return;
    queue<Node *> q;
    q.push(root);
    q.push(NULL);
    vector<int> tmp;

    while (1)
    {
        Node *val = q.front();
        q.pop();
        if (val == NULL && q.empty())
            break;
        if (val == NULL && q.size())
        {
            ans.push_back(tmp);
            tmp.clear();
            q.push(NULL);
            continue;
        }
        tmp.push_back(val->data);
        if (val->left)
            q.push(val->left);
        if (val->right)
            q.push(val->right);
    }
    if (tmp.size())
        ans.push_back(tmp);
}

vector<int> leftView(Node *root)
{
    vector<vector<int>> ans;
    levelorder(root, ans);
    vector<int>tmp;
    for(int i=0;i<ans.size();i++)
        tmp.push_back(ans[i][0]);
    return tmp;
}
	Here, we need to store level order traversal level wise and print the first element of each level in the left view.
Similarly for the right view, print the last element of each level.

51.
	vector<int> verticalOrder(Node *root)
    {
        vector<int>tmp;
        if (!root)
            return tmp;

        map<int, vector<int> > m;
        int hd = 0;
        
        queue<pair<Node*, int> > que;
        que.push(make_pair(root, hd));
    
        while (!que.empty()) 
        {
            pair<Node*, int> temp = que.front();
            que.pop();
            hd = temp.second;
            Node* node = temp.first;
    
            m[hd].push_back(node->data);
    
            if (node->left != NULL)
                que.push(make_pair(node->left, hd - 1));
            if (node->right != NULL)
                que.push(make_pair(node->right, hd + 1));
        }
    
        map<int, vector<int> >::iterator it;
        for (it = m.begin(); it != m.end(); it++) 
        {
            for (int i = 0; i < it->second.size(); ++i)
                tmp.push_back(it->second[i]);
        }
        return tmp;
    }

52.
	void printLeftBoundary(Node* root, vector<int>&ans)
    {
        if(root)
        {
            if(root->left)
            {
                ans.push_back(root->data);
                printLeftBoundary(root->left, ans);
            }
            else if(root->right)
            {
                ans.push_back(root->data);
                printLeftBoundary(root->right, ans);
            }
        }
    }
    
    void printRightBoundary(Node* root, vector<int>&ans)
    {
        if(root)
        {
            if(root->right)
            {
                printRightBoundary(root->right, ans);
                ans.push_back(root->data);
            }
            
            else if(root->left)
            {
                printRightBoundary(root->left, ans);
                ans.push_back(root->data); 
            }
        }
    }
    
    void printLeafNodes(Node* root, vector<int>&ans)
    {
        if(root)
        {
            printLeafNodes(root->left, ans);
            if(root->left==NULL&&root->right==NULL)
                ans.push_back(root->data);
            printLeafNodes(root->right, ans);
        }
    }
    
    vector <int> printBoundary(Node *root)
    {
        vector<int>ans;
        ans.push_back(root->data);
        printLeftBoundary(root->left, ans);
        printLeafNodes(root->left, ans);
        printLeafNodes(root->right, ans);
        printRightBoundary(root->right, ans);
        return ans;
    }

53.
	void helper(Node* root, Node** prev, Node** head)
    {
        if(root==NULL)
            return;
        helper(root->left, prev, head);
        if((*prev)==NULL)
            (*prev) = root, (*head) = root;
        else
        {
            root->left = *prev;
            (*prev)->right = root;
            (*prev) = root;
        }
        helper(root->right, prev, head);
    }

    Node *bToDLL(Node *root)
    {
        Node* prev = NULL;
        Node* head = NULL;
        helper(root, &prev, &head);
        return head;
    }

54.
	int maxPath(Node* root, int &ans)
{ 
    if(root==NULL)
        return 0;
    if(root->left==NULL&&root->right==NULL)
        return root->data;
    int l = maxPath(root->left, ans);
    int r = maxPath(root->right, ans);
    
    if(root->left&&root->right)
    {
        ans = max(ans, l+r+(root->data));
        return max(l,r)+(root->data);
    }
    return ((root->left)?l+(root->data):r+(root->data));
}

int maxPathSum(Node* root)
{
    int ans = INT_MIN;
    int val = maxPath(root, ans);
    if(ans==INT_MIN)
        return val;
    return ans;
}

55.
	struct Info {
    int lDepth;
    int rDepth;
    bool contains;

    int time;

    Info()
    {
        lDepth = rDepth = 0;
        contains = false;

        time = -1;
    }
};

/*  
    Function to calculate time required to burn 
    tree completely
    
    node - address of current node
    info - extra information about current node
    target - node that is fired
    res - stores the result
*/
Info calcTime(Node* node, Info& info, int target, int& res)
{

    // Base case: if root is null
    if (node == NULL) {
        return info;
    }

    // If current node is leaf
    if (node->left == NULL && node->right == NULL) {

        // If current node is the first burnt node
        if (node->data == target) {
            info.contains = true;
            info.time = 0;
        }
        return info;
    }

    // Information about left child of root
    Info leftInfo;
    calcTime(node->left, leftInfo, target, res);

    // Information about right child of root
    Info rightInfo;
    calcTime(node->right, rightInfo, target, res);

    // If left subtree contains the fired node then
    // time required to reach fire to current node
    // will be (1 + time required for left child)
    info.time = (node->left && leftInfo.contains) ? (leftInfo.time + 1) : -1;

    // If right subtree contains the fired node then
    // time required to reach fire to current node
    // will be (1 + time required for right child)
    if (info.time == -1)
        info.time = (node->right && rightInfo.contains) ? (rightInfo.time + 1) : -1;

    // Storing(true or false) if the tree rooted at
    // current node contains the fired node
    info.contains = ((node->left && leftInfo.contains) || (node->right && rightInfo.contains));

    // Calculate the maximum depth of left subtree
    info.lDepth = !(node->left) ? 0 : (1 + max(leftInfo.lDepth, leftInfo.rDepth));

    // Calculate the maximum depth of right subtree
    info.rDepth = !(node->right) ? 0 : (1 + max(rightInfo.lDepth, rightInfo.rDepth));

    // Calculating answer
    if (info.contains) {
        // If left subtree exists and
        // it contains the fired node
        if (node->left && leftInfo.contains) {
            // calculate result
            res = max(res, info.time + info.rDepth);
        }

        // If right subtree exists and it
        // contains the fired node
        if (node->right && rightInfo.contains) {
            // calculate result
            res = max(res, info.time + info.lDepth);
        }
    }
}

// Driver function to calculate minimum
// time required
int minTime(Node* root, int target)
{
    int res = 0;
    Info info;

    calcTime(root, info, target, res);

    return res;
}

56.
	Node * inOrderSuccessor(Node *root, Node *x)
    {
        if(x==NULL)
            return NULL;
        Node* tmp=NULL;
        if(x->right)
        {
            tmp = x->right;
            Node* prev = NULL;
            while(tmp)
            {
                prev = tmp;
                tmp = tmp->left;
            }
            tmp = prev;
        }
        else
        {
            while(root!=x)
            {
                if(root->data > x->data)
                {
                    tmp = root;
                    root = root->left;
                }
                else
                {
                    root = root->right;
                }
            }
        }
        return tmp;
    }
Inorder Successor - If the root has the right child, then return the left-most value(smallest value in the right subtree) of the right subtree, else start from the root and reach the target node, the node at which the last left was taken, is the inorder successor.
Similarly, Inorder Predecessor - If the root has the left child, then return the right-most value(largest value in the right subtree) of the left subtree, else start from the root and reach the target node, the node at which the last right was taken, is the inorder predecessor.

57.
	bool isBST(Node* root) 
    {
        if(root==NULL)
            return true;
        if(root->left==NULL&&root->right==NULL)
            return true;
        if(isBST(root->left)&&isBST(root->right))
        {
            Node* tmp;
            if(root->left)
            {
                tmp = root->left;
                while(tmp->right)
                    tmp = tmp->right;
                if(tmp->data >= root->data)
                    return false;
            }
            
            if(root->right)
            {
                tmp = root->right;
                while(tmp->left)
                    tmp = tmp->left;
                if(tmp->data < root->data)
                    return false;
            }
            return true;
        }
        else
            return false;
    }

58.
	void helper(int* arr, int s, int e, vector<int>&ans)
    {
        if(s>e)
            return;
        int mid = (s+e)/2;
        ans.push_back(arr[mid]);
        helper(arr,s,mid-1,ans);
        helper(arr,mid+1,e, ans);
    }
    
    vector<int> sortedArrayToBST(vector<int>& nums) 
    {
        int* arr = new int[nums.size()];
        for(int i=0;i<nums.size();i++)
            arr[i] = nums[i];
        vector<int>ans;
        helper(arr, 0, nums.size()-1, ans);
        return ans;
    }

59.
	Node* removekeys(Node* root, int l, int r) 
    {
        if(root==NULL)
            return NULL;
            
        root->left = removekeys(root->left, l, r);
        root->right = removekeys(root->right, l, r);
        
        if(root->data < l)
        {
            Node* ans = root->right;
            delete root;
            return ans;
        }
        
        if(root->data > r)
        {
            Node* ans = root->left;
            delete root;
            return ans;
        }
            
        return root;
    }

60.
	/*void inorder(Node* root, vector<int> &ans)
    {
        if(root==NULL)
            return;
        inorder(root->left, ans);
        ans.push_back(root->data);
        inorder(root->right, ans);
    }*/
    
    int isPairPresent(struct Node *root, int target)
    {
        /*vector<int>ans;
        inorder(root, ans);
        int l=0, r=ans.size()-1;
        while(l<r)
        {
            int sum = ans[l]+ans[r];
            if(sum==target)
                return 1;
            else if(sum<target)
                l++;
            else
                r--;
        }
        return 0;*/
        stack<Node*>s1;
        stack<Node*>s2;
        Node* tmp1 = root, *tmp2 = root;
        int val1 =0, val2=0;
        bool d1=0,d2=0;
        while(1)
        {
            while(!d1)
            {
                if(tmp1)
                {   
                    s1.push(tmp1);
                    tmp1 = tmp1->left;
                }
                else
                {
                    if(s1.size())
                    {
                        tmp1 = s1.top();
                        s1.pop();
                        val1 = tmp1->data;
                        tmp1 = tmp1->right;
                    }
                    d1=1;
                }
            }
            
            while(!d2)
            {
                if(tmp2)
                {   
                    s2.push(tmp2);
                    tmp2 = tmp2->right;
                }
                else
                {
                    if(s2.size())
                    {
                        tmp2 = s2.top();
                        s2.pop();
                        val2 = tmp2->data;
                        tmp2 = tmp2->left;
                    }
                    d2=1;
                }
            }
            
            if(val1!=val2&&(val1+val2)==target)
                return 1;
            
            else if((val1+val2)<target)
                d1=0;
            
            else if((val1+val2)>target)
                d2=0;
                
            if(val1>=val2)
                return false; // inorder traversals crossed each other
        }
    }

61.
	int canRepresentBST(int arr[], int n) 
    {
        stack<int>s;
        int root = INT_MIN;
        for(int i=0;i<n;i++)
        {
            if(arr[i]<root)
                return false;
            
            while(s.size()&&s.top()<arr[i])
            {
                root = s.top();
                s.pop();
            }
            
            s.push(arr[i]);
        }
        return true;
    }

62.
	unsigned int getFirstSetBit(int n)
    {
        /*string s = "";
        while(n)
        {
            int ans = n%2;
            s = to_string(ans)+s;
            n=n/2;
        }
        for(int i=s.size()-1;i>=0;i--)
            if(s[i]=='1')
                return s.size()-i;
        return 0;*/
        
        return 1+log2(n&(-n));

        // return ffs(n);
        
        /*if(n==0)
            return 0;
        int pos=1;
        int m=1;
        while(!(n&m))
        {
            m = m << 1;
            pos++;
        }
        return pos;*/
        
        /*int pos=0;
        while(n)
        {
            if(n&1)
                return ++pos;
            pos++;
            n = n>>1;
        }
        return pos;8/
    }

63.
	bool isPowerofTwo(long long n)
    {
        /*long long m =1;
        while(n>=m)
        {
            if(n==m)
                return true;
            m = m << 1;
        }
        return false;*/
        
        return n&&(!(n&(n-1)));
        
        //method to count set bits
        
        /*int ct=0;
        while(n)
        {
            n &= (n-1);
            ct++;
        }
        return (ct==1);*/
    }

64.
	unsigned int swapBits(unsigned int n)
    {
    	unsigned int a = n&0xAAAAAAAA; // even bits
    	unsigned int b = n&0x55555555; // odd bits
    	return (a>>1) | (b<<1);
    }

65.
	vector <int> rotate (int n, int d)
        {
            vector<int>ans;
            ans.push_back((n<<d)|n>>(32-d));
            ans.push_back((n>>d)|n<<(32-d));
            return ans;
        }

66.
	long long reversedBits(long long num) 
    {
        unsigned int count = 31;
        unsigned int reverse_num = num;
        
        num >>= 1; 
        while(num)
        {
           reverse_num <<= 1;       
           reverse_num |= num & 1;
           num >>= 1;
           count--;
        }
        reverse_num <<= count;
        return reverse_num;
    }

67.
	int sum(int a , int b)
    {   
        if(b==0)
            return a;
        return sum(a^b, (a&b)<<1);
    }

68.
	int check(int pattern, int arr[], int n)
	{
	    int ct=0;
	    for(int j=0;j<n;j++)
	       if((arr[j]&pattern)==pattern)
	            ct++;
	    return ct;
	}
	int maxAND (int arr[], int n)
	{
	    int res=0,ct;
	    for(int i=31;i>=0;i--)
	    {
	        ct = check(res|(1<<i), arr, n);
	        if(ct>=2)
	            res = res|(1<<i);
	    }
	    return res;
	}

69.
	int maxSubarrayXOR(int set[], int n)
    {
        int index=0, INT_BITS = 32;
        for (int i = INT_BITS-1; i >= 0; i--)
        {
            int maxInd = index;
            int maxEle = INT_MIN;
            for (int j = index; j < n; j++)
            {
                if ((set[j] & (1 << i))!= 0&& set[j] > maxEle)
                    maxEle = set[j], maxInd = j;
            }
            
            if (maxEle == INT_MIN)
                continue;
    
            swap(set[index], set[maxInd]);
            maxInd = index;
   
            for (int j=0; j<n; j++)
            {
                if (j != maxInd && (set[j] & (1 << i)) != 0)
                    set[j] = set[j] ^ set[maxInd];
            }
            index++;
        }
        int res = 0;
        for (int i = 0; i < n; i++)
            res ^= set[i];
        return res;
    }

70.
	int countBits(int n, long long int a[])
    {
        unsigned int ans=0, mod = 1000000007;
        for(int i=0;i<32;i++)
        {
            int ct=0;
            for(int j=0;j<n;j++)
            {
                if(a[j]&(1<<i))
                    ct++;
            }
            ans += ct*(n-ct)*2;
            ans %= mod;
        }
        return ans%mod;
    }

71.
	ll findSubarray(vector<ll> arr, int n ) 
    {
        unordered_map<ll, vector<ll> > map;
        vector <pair<ll, ll>> out;
        ll sum = 0;
       
        for (ll i = 0; i < n; i++)
        {
            sum += arr[i];
            if (sum == 0)
                out.push_back(make_pair(0, i));
    
            if (map.find(sum) != map.end())
            {
                vector<ll> vc = map[sum];
                for (int j = 0; j < vc.size(); j++)
                    out.push_back(make_pair(vc[j] + 1, i));
            }
       
            map[sum].push_back(i);
        }
       
        return out.size();
    }

72.
	void findpair(vector<int> &arr, int b, vector<vector<int>> &ans, vector<int>r, int i)
    {
        if (b == 0) 
        {
            ans.push_back(r);
            return;
        }
     
        while (i < arr.size() && b >= arr[i]) 
        {
            r.push_back(arr[i]);
            findpair(arr, b - arr[i], ans, r, i+1);
            i++;
            r.pop_back();
        }
    }
    
    vector<vector<int>> combinationSum(vector<int> &arr, int n, int b)
    {
        sort(arr.begin(), arr.end());
        vector<vector<int>>ans;
        vector<int>r;
        findpair(arr, b, ans, r, 0);
        map<vector<int>,int>mp;
        for(int i=0;i<ans.size();i++)
            mp[ans[i]]++;
        vector<vector<int>>final;
        for(auto i=mp.begin();i!=mp.end();i++)
        {
            final.push_back(i->first);
        }
        return final;
    }

73.
	int eggDrop(int n, int k) 
    {
        /*if(n==1)
            return k;
        if(k==1)
            return 1;
        if(k==0)
            return 0;
        int ans = INT_MAX;
        int r = INT_MIN;
        for(int i=1;i<=k;i++)
        {
            r = max(eggDrop(n,k-i), eggDrop(n-1,i-1));
            if(ans > r)
                ans = r;
        }
        return ans+1;*/
        int **dp = new int*[n+1];
        for(int i=0;i<=n;i++)
        {
            dp[i] = new int[k+1];
        }
        
        for(int i=0;i<=n;i++)
        {
            dp[i][0]=0;
            dp[i][1]=1;
        }
        
        for(int i=0;i<=k;i++)
        {
            dp[1][i] = i;
        }
        
        for(int i=2;i<=n;i++)
        {
            for(int j=2;j<=k;j++)
            {
                int r = INT_MIN, ans = INT_MAX;
                for(int x=1;x<=j;x++)
                {
                    r = max(dp[i][j-x], dp[i-1][x-1]);
                    if(ans>r)
                        ans = r;
                }
                dp[i][j] = ans+1;
            }
        }
        return dp[n][k];
    }


74.
	long long int count( int S[], int m, int n)
    {
        /*if(n<0)
            return 0;
        if(n==0)
            return 1;
        if(m<=0&&n>=1)
            return 0;
        return count(S, m-1, n)+count(S,m,n-S[m-1]);
        long long** dp = new long long*[n+1];
        for(int i=0;i<=n;i++) 
        {
            dp[i] = new long long[m+1];
            for(int j=0;j<=m;j++)
                dp[0][j]=1;
            dp[i][0] = 0;
        }
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=m;j++)
            {
                if(i>=S[j-1])
                    dp[i][j] = dp[i][j-1]+dp[i-S[j-1]][j];
                else
                    dp[i][j] = dp[i][j-1];
            }
        }
        return dp[n][m];*/
        
        long long* dp = new long long[n+1];
        for(int i=0;i<=n;i++)
            dp[i]=0;
        dp[0]=1;
        for(int i=0;i<m;i++)
        {
            for(int j=S[i];j<=n;j++)
                dp[j] += dp[j-S[i]];
        }
        return dp[n];
    }

75.
	 int maxProduct(vector<string>& words) 
    {
        int n = words.size();
        unordered_map<string, int>mp;
        for(int i=0;i<n;i++)
        {
            mp[words[i]]=0;
            for(int j=0;j<words[i].size();j++)
            {
                mp[words[i]]=(mp[words[i]] | (1<<(words[i][j]-'a')));
            }
        }
        
        int ans = 0;
        
        for(int i=0;i<n-1;i++)
        {
            for(int j=i+1;j<n;j++)
            {
                if((mp[words[i]]&mp[words[j]])==0)
                {
                    if(ans < (words[i].size())*(words[j].size()))
                        ans = (words[i].size())*(words[j].size());
                }
            }
        }
        return ans;
    }

76.
	int longestSubsequence_h(int n, int a[], int &max)
    {
        if (n == 1)
        {
            //cout << n << " " << 1 << " " << max << endl;
            return 1;
        }
    
        int ans = 1;
        for (int i = n - 1; i > 0; i--)
        {
            int possible = 1 + longestSubsequence_h(i, a, max);
            if ((a[n - 1] > a[i - 1]) && ans < possible)
                ans = possible;
        }
        if (ans > max)
            max = ans;
        //cout << n << " " << ans << " " << max << endl;
        return ans;
    }
    
    int pos(int* v, int l, int r, int val)
    {
       while ((r - l) > 1) 
       {
            int m = (r + l) / 2;
            if (v[m] >= val)
                r = m;
            else
                l = m;
        }
 
        return r;
    }
    
    int longestSubsequence(int n, int a[])
    {
        /*int max = 1;
        int ans = longestSubsequence_h(n, a, max);
        return max;*/
        
        /*int *ans = new int[n];
        ans[0] = 1;
        for (int i = 1; i < n; i++)
        {
            ans[i] = 1;
            for (int j = i - 1; j >= 0; j--)
            {
                if (a[j] < a[i])
                {
                    int possibleAns = ans[j] + 1;
                    if (possibleAns > ans[i])
                    {
                        ans[i] = possibleAns;
                    }
                }
            }
        }

        int m = 0;
        for (int i = 0; i < n; i++)
            if (m < ans[i])
                m = ans[i];
        delete[] ans;
        return m;*/
        
        int* v = new int[n];
        for(int i=0;i<n;i++)
            v[i]=0;
        v[0]=a[0];
        int len=1;
        for(int i=1;i<n;i++)
        {
            if(v[0]>a[i])
                v[0]=a[i];
            else if(v[len-1]<a[i])
                v[len++]=a[i];
            else
                v[pos(v, -1, len-1, a[i])]=a[i];
        }
        return len;
    }

77.
	struct Box
{
  // h --> height, w --> width, d --> depth
  int h, w, d;  // for simplicity of solution, always keep w <= d
};

// A utility function to get minimum of two intgers
int min (int x, int y)
{ return (x < y)? x : y; }

// A utility function to get maximum of two intgers
int max (int x, int y)
{ return (x > y)? x : y; }

/* Following function is needed for library function qsort(). We
   use qsort() to sort boxes in decreasing order of base area. 
   Refer following link for help of qsort() and compare()
   http://www.cplusplus.com/reference/clibrary/cstdlib/qsort/ */
int compare (const void *a, const void * b)
{
    return ( (*(Box *)b).d * (*(Box *)b).w ) -
           ( (*(Box *)a).d * (*(Box *)a).w );
}

/* Returns the height of the tallest stack that can be
   formed with give type of boxes */
int maxStackHeight( Box arr[], int n )
{
   /* Create an array of all rotations of given boxes
      For example, for a box {1, 2, 3}, we consider three
      instances{{1, 2, 3}, {2, 1, 3}, {3, 1, 2}} */
   Box rot[3*n];
   int index = 0;
   for (int i = 0; i < n; i++)
   {
      // Copy the original box
      rot[index].h = arr[i].h;
      rot[index].d = max(arr[i].d, arr[i].w);
      rot[index].w = min(arr[i].d, arr[i].w);
      index++;

      // First rotation of box
      rot[index].h = arr[i].w;
      rot[index].d = max(arr[i].h, arr[i].d);
      rot[index].w = min(arr[i].h, arr[i].d);
      index++;

      // Second rotation of box
      rot[index].h = arr[i].d;
      rot[index].d = max(arr[i].h, arr[i].w);
      rot[index].w = min(arr[i].h, arr[i].w);
      index++;
   }

   // Now the number of boxes is 3n
   n = 3*n;

   /* Sort the array 'rot[]' in non-increasing order
      of base area */
   qsort (rot, n, sizeof(rot[0]), compare);

   // Uncomment following two lines to print all rotations
   // for (int i = 0; i < n; i++ )
   //    printf("%d x %d x %d\n", rot[i].h, rot[i].w, rot[i].d);

   /* Initialize msh values for all indexes 
      msh[i] --> Maximum possible Stack Height with box i on top */
   int msh[n];
   for (int i = 0; i < n; i++ )
      msh[i] = rot[i].h;

   /* Compute optimized msh values in bottom up manner */
   for (int i = 1; i < n; i++ )
      for (int j = 0; j < i; j++ )
         if ( rot[i].w < rot[j].w &&
              rot[i].d < rot[j].d &&
              msh[i] < msh[j] + rot[i].h
            )
         {
              msh[i] = msh[j] + rot[i].h;
         }


   /* Pick maximum of all msh values */
   int max = -1;
   for ( int i = 0; i < n; i++ )
      if ( max < msh[i] )
         max = msh[i];

   return max;
}

78.
	string longestPalindrome(string s)
    {
        int n = s.size();
        /*int **dp = new int*[n];
        for(int i=0;i<n;i++)
        {
            dp[i]=new int[n];
            for(int j=0;j<n;j++)
                dp[i][j]=0;
        }
        
        int start=0, maxlen=1;
        for(int i=0;i<n;i++)
        {
            dp[i][i]=1;
        }
        
        for(int k=2;k<=n;k++)
        {
            for(int i=0;i<n-k+1;i++)
            {
                int j = i+k-1;
                if(k==2&&s[i]==s[j])
                {
                    if(maxlen!=k)
                        start = i;
                    dp[i][j]=1;
                    maxlen=k;
                }
                else if(dp[i+1][j-1]&&s[i]==s[j])
                {
                    dp[i][j]=1;
                    if(k>maxlen)
                    {
                        start = i;
                        maxlen = k;
                    }
                }
            }
        }
        return s.substr(start,maxlen);*/
        
        int maxlen=1,start=0;
        for(int i=1;i<n;i++)
        {
            int low = i-1;
            int high = i+1;
            while(low>=0&&high<n&&s[low]==s[high])
            {
                if(high-low+1>maxlen)
                {
                    start=low;
                    maxlen=high-low+1;
                }
                low--;
                high++;
            }
            
            low = i-1;
            high=i;
            while(low>=0&&high<n&&s[low]==s[high])
            {
                if(high-low+1>maxlen)
                {
                    start=low;
                    maxlen=high-low+1;
                }
                low--;
                high++;
            }
        }
        return s.substr(start, maxlen);
    }

79.
	int lcs(string s1,string s2, int n, int m, int count)
    {
        if(n==0)
            return count;
        if(m==0)
            return count;
        if(s1[n-1]==s2[m-1])
            count = lcs(s1, s2, n-1, m-1, count+1);
        count = max(count, max(lcs(s1,s2,n-1,m,0), lcs(s1,s2,n,m-1,0)));
        return count;
    }
    
    int longestCommonSubstr (string S1, string S2, int n, int m)
    {
        /*int count=0;
        return lcs(S1, S2, n, m, count);*/
        
        int** dp = new int*[n+1];
        for(int i=0;i<=n;i++)
        {
            dp[i]=new int[m+1];
            dp[i][0]=0;
            for(int j=0;j<=m;j++)
                dp[0][j]=0;
        }
        
        int ans = 0;
        
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=m;j++)
            {
                if(S1[i-1]==S2[j-1])
                    dp[i][j] = 1+dp[i-1][j-1], ans = max(ans, dp[i][j]);
                else
                {
                    dp[i][j] = 0;
                }
            }
        }
        return ans;
    }

80.
	int majorityElement(vector<int>& nums) 
    {
        int n = nums.size();
        int major=nums[0], ct=1;
        for(int i=1;i<n;i++)
        {
            if(ct==0)
            {
                ct++;
                major = nums[i];
            }
            else if(nums[i]==major)
                ct++;
            else
                ct--;
        }
        return major;
    }


81.
	void moveZeroes(vector<int>& nums) 
    {
        int n = nums.size(); int j=0;
        /*for(int i=0;i<n;i++)
        {
            if(nums[i]!=0)
                nums[j++]=nums[i];
        }
        for(;j<n;j++)
            nums[j]=0;*/
        for(int i=0;i<n;i++)
        {
            if(nums[i]==0)
                j++;
            else
            {
                swap(nums[i-j], nums[i]);
            }
        }
    }

82.
	int next(int n)
    {
        int ans=0;
        while(n)
        {
            ans += (n%10)*(n%10);
            n = n/10;
        }
        return ans;
    }
    bool isHappy(int n) 
    {
        int slow = next(n), fast = next(next(n));
        if(slow==1)
            return true;
        if(fast==1)
            return true;
        while(slow!=fast)
        {
            slow = next(slow);
            fast = next(next(fast));
            if(fast==1)
                return true;
        }
        return false;
    }

83.
	int wildCard(string pattern,string str)
    {
        /*if(pattern.size()==0)
        {
            if(str.size()==0)
                return 1;
            else return 0;
        }

        if(pattern[0]=='*')
        {
            if(str.size()==0)
                return true;
            if(pattern.size()==1)
                return true;
            int ans = 0;
            for(int i=0;i<str.size();i++)
                ans = ans || wildCard(pattern.substr(1), str.substr(i));
            return ans;
        }
        if(pattern[0]==str[0] || pattern[0]=='?')
        {
            return wildCard(pattern.substr(1), str.substr(1));
        }
        else return false;*/
        
        int n = str.size(), m = pattern.size();
        int** dp = new int*[n+1];
        for(int i=0;i<=n;i++)
        {
            dp[i] = new int[m+1];
            dp[i][0] = 0;
        }
        dp[0][0]=1;
        
        for(int j=1;j<=m;j++)
            dp[0][j] = dp[0][j-1] && (pattern[m-j]=='*');
            
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=m;j++)
            {
                if(pattern[m-j]=='*')
                    dp[i][j] = (dp[i][j-1] || dp[i-1][j]);
                else if(pattern[m-j]==str[n-i] || pattern[m-j]=='?')
                    dp[i][j] = dp[i-1][j-1];
                else dp[i][j] = 0;
            }
        }
        
        return dp[n][m];
    }




















	















Puzzles

https://www.geeksforgeeks.org/puzzle-1-how-to-measure-45-minutes-using-two-identical-wires/
https://www.geeksforgeeks.org/puzzle-2-find-ages-of-daughters/
https://www.geeksforgeeks.org/puzzle-4-pay-an-employee-using-a-gold-rod-of-7-units/
https://www.geeksforgeeks.org/c-program-to-print-numbers-from-1-to-n-without-using-semicolon/
https://www.geeksforgeeks.org/to-find-sum-of-two-numbers-without-using-any-operator/
https://www.geeksforgeeks.org/how-will-you-show-memory-representation-of-c-variables/
https://www.geeksforgeeks.org/condition-to-print-helloword/
https://www.geeksforgeeks.org/changeadd-only-one-character-and-print-exactly-20-times/
Scope resolution operator and extern keyword
https://www.geeksforgeeks.org/g-fact-21/
https://www.geeksforgeeks.org/can-access-private-data-members-class-without-using-member-friend-function/
https://www.geeksforgeeks.org/make-class-whose-objects-can-dynamically-allocated/


